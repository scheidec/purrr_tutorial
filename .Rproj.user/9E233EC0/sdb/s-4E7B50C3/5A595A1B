{
    "collab_server" : "",
    "contents" : "---\ntitle: \"purrr Tutorial\"\nauthor: \"Caleb Scheidel\"\ndate: \"6/30/2017\"\noutput: \n  ioslides_presentation:\n    widescreen: true\n    smaller: true\n    logo: methods_logo.png\n    css: purrr_tutorial.css\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n\nlibrary(purrr)\nlibrary(devtools)\nlibrary(repurrrsive)\nlibrary(listviewer)\nlibrary(knitr)\nlibrary(tibble)\nlibrary(tidyverse)\n\n```\n\n## Tutorial Outline\n\n1. Introduce advantages of `purrr` package\n\n2. Use GoT dataset to run through examples of commonly used `purrr` functions: \n    - `map()`, \n    - `map_at()`\n    - `map_if()`\n    - `lmap()`\n    - `walk()`\n    - `reduce()`\n    - `keep()`\n    - `discard()`\n    - `map2()`\n    - `pmap()` \n\n3. Walk through a real example where I learned the hard way that `purrr` makes our work easier and more readable to others  \n\n# Advantages of `purrr` package\n\n## Advantages of `purrr`\n\n- efficient, can do more in less code\n- `map()` has several advantages over `lapply()`\n    - allows you to bypass the `function` function using `~` in place of `function` and a `.` in place of x\n    - several versions of `map()` that allow you to specify the structure of your output\n    - can easily nest `map()` functions inside of each other.\n    \n- Disadvantages: wierd working with dates, purrr/purrrlyr conflicts\n\n#  Use GoT dataset to run through examples\n\n## GoT Characters Dataset\n\n- `got_chars` dataset from the `repurrrsive` package\n\n- contains data on all of the point-of-view characters from the Game of Thrones book series in a list of lists format\n\n- The highest-level list contains 29 characters, with each character having a list of 18 variables containing information pertaining to each character, i.e. `name`, `gender`, and `culture`.\n\n--- \n\n```{r, include = TRUE}\n\n#Only viewing elements of the first character's list\nstr(got_chars[1])\n\n```\n\n## Introduction to `map()`: extract elements {.smaller}\n\n- `map()` is a function for applying a function to each element of a list.\n\n- Basic map usage: `map(YOUR_LIST, YOUR_FUNCTION)`\n\n- First, a quick example, taking the square root of a list of three numbers:\n\n```{r}\n\nmap(c(9, 16, 26), sqrt)\n\n```\n\n## Using `map()` to extract character names\n\nUsing the GoT characters dataset, pulling out the names from specified characters:\n\n```{r}\n\n#name and position shortcuts\nmap(got_chars[1:2], \"name\")\n\n#can rewrite using the pipe\ngot_chars[1:2] %>% \n  map(\"name\")\n\n```\n\n## Type-specific maps\n\nYou can specify type-specific variants to map, such as `map_chr()`, `map_lgl()`, `map_int()`, and `map_dbl()`:\n\n```{r}\n\nmap_chr(got_chars[9:12], \"name\")\n\nmap_int(got_chars[9:12], \"id\")\n\nmap_lgl(got_chars[9:12], \"alive\")\n\n```\n\n## Extract multiple values without using `map()`\n\n- How to retrieve multiple elements without using `map()`:\n\n```{r}\n\ngot_chars[[3]][c(\"name\", \"culture\", \"born\")]\n\n```\n\n## Extract multiple values using `map()`\n\n- Recall map() usage: `map(.x, .f, ...)`\n\n- The function .f will be `[`.  We use `...` to pass the character vector of the names of desired elements \n\n```{r}\n\nx <- map(got_chars, `[`, c(\"name\", \"culture\", \"gender\", \"born\"))\nstr(x[16:17])\n\n```\n\n## Extract multiple values using `map()`\n\n- This can be rewritten using the pipe and `extract()` function from `magrittr`:\n\n```{r warning=FALSE, message=FALSE}\n\nlibrary(magrittr)\n\nx <- got_chars %>% \n  map(extract,  c(\"name\", \"culture\", \"gender\", \"born\"))\n  \nstr(x[18:19])\n\n```\n\n## `map_df()` to put output into a dataframe\n\n- To get output into a dataframe, use `map_df()`:\n\n```{r}\n\ngot_char <- map_df(got_chars, extract, c(\"name\", \"culture\", \"gender\", \"id\", \"born\", \"alive\"))\n\ngot_char %>% tail() %>% kable()\n\n```\n\n## Specifying the function in map()\n\n- map() function specification\n\n- Recall map() usage: `map(.x, .f, ...)`\n\n- Three more ways to specify a general function, `.f`:\n\n    1. an existing function\n    2. an anonymous function, defined on the fly\n    3. a formula\n\n## `map()` function specification\n\n- Each GoT character can have aliases, which are stored as a list for each character.\n\n- We want to present each character's aliases combined together in one variable, separated by \" | \".  \n\n- There are three ways to go about doing this using `map()`:\n\n    1. an existing function\n    2. an anonymous function, defined on the fly\n    3. a formula\n    \n---\n\nFirst, pull a few to use in this demo:\n\n```{r}\n\naliases <- set_names(map(got_chars, \"aliases\"),\n                     map_chr(got_chars, \"name\"))\n\n(aliases <- aliases[c(\"Daenerys Targaryen\", \"Jon Snow\")])\n\n```\n\n## 1. Existing function\n\n- We can define our own function and use it in `map()`:\n\n```{r}\n\nmy_fun <- function(x) paste(x, collapse = \" | \")\nmap(aliases, my_fun)\n\n```\n\n## 2. Anonymous function, conventional\n\n- We can also define the function on the fly in the `map()` function itself:\n\n```{r}\n\nmap(aliases, function(x) paste(x, collapse = \" | \"))\n\n#or rewrite it as\nmap(aliases, paste, collapse = \" | \")\n\n```\n\n## 3. Anonymous function, formula\n\n- purrr provides a concise way to define an anonymous function: as a formula.  \n- This should start with the `~` symbol and then look like a typical expression.  \n    - Use `.x` to refer to the input, i.e. an individual element of the primary vector or list.\n\n```{r}\n\nmap(aliases, ~ paste(.x, collapse = \" | \"))\n\n```\n\n## Converting `aliases` list to a data frame\n\n- Since we've simplified the aliases to a single string for each character, we can hold them as an atomic character vector instead of as a list.  \n    - The `tibble::enframe()` function takes a named vector and promotes the names to a proper variable.\n\n```{r}\n\naliases <- set_names(map(got_chars, \"aliases\"), map_chr(got_chars, \"name\"))\n\naliases_df <- map_chr(aliases[c(9, 23)], ~ paste(.x, collapse = \" | \")) %>% \n  tibble::enframe(value = \"aliases\")\n\naliases_df %>% kable()\n\n```\n\n## `map_at()`\n\n- `map_at()` maps a function over the elements corresponding to a character vector of names or a numeric vector of positions\n- For example, in the `got_char` dataframe we created earlier, we want to change both `culture` and `gender` variables from `chr` to `fctr`:\n\n```{r}\n\ngot_char %>%\n  map_at(c(\"culture\", \"gender\"), as.factor) %>%\n  str()\n\n```\n\n## `map_if()`\n\n- `map_if()` maps a function over the elements of .x satisfying a predicate.\n- For example, we want to change any `int` type variables to `chr` (in this dataset, that is only `id`)\n\n```{r}\n\ngot_char %>%\n  map_if(is_integer, as.character) %>%\n  str()\n\n```\n\n## `lmap()`, `lmap_at()`, and `lmap_if()`\n\n- Operate exclusively on functions that take and return a list (or data frame)\n- First, we need a function that takes and returns a list, for example `disjoin`, which takes all factor variables and creates new columns for each factor level:\n\n```{r}\n\ndisjoin <- function(x, sep = \"_\") {\n  name <- names(x)\n  x <- as.factor(x[[1]])\n\n  out <- lapply(levels(x), function(level) {\n    as.numeric(x == level)\n  })\n\n  names(out) <- paste(name, levels(x), sep = sep)\n  dplyr::as_data_frame(out)\n}\n\n```\n\n- We can then create binary variables for each culture and gender in the `got_char` data -------------->\n\n## `lmap()`, `lmap_at()`, and `lmap_if()`\n\n```{r}\n\ngot_char %>%\n  select(name, culture, gender) %>% \n  filter(culture == \"Ironborn\" | culture == \"Free Folk\") %>% \n  map_at(c(\"culture\", \"gender\"), as.factor) %>% \n  lmap_if(is.factor, disjoin) %>% \n  as.data.frame() %>% tail() %>% kable()\n\n```\n\n\n## Parallel mapping using `map2()`\n\n- You can use `map2()` to map a function over two vectors or lists in parallel.  Here is the usage:\n\n- `map2(.x, .y, .f, ...)` \n\nor\n\n- `map2(INPUT_ONE, INPUT_TWO, FUNCTION_TO_APPLY, OPTIONAL_OTHER_STUFF)`\n\n- It can also be type specific: `map2_chr()`, `map2_dbl()`, etc.\n\n- For our example, we will paste the character's name and the date and location of his or her birth to get a sentence.\n\n- First, obtain the two inputs:\n\n```{r}\n\nnms <- got_chars %>% \n  map_chr(\"name\")\n\nbirth <- got_chars %>% \n  map_chr(\"born\")\n\n```\n\n## Parallel mapping using `map2()` | 1. Map over both with an existing function, defined by us:\n\n```{r}\n\nmy_fun <- function(x, y) paste(x, \"was born\", y)\nmap2_chr(nms, birth, my_fun) %>% \n  head()\n\n```\n\n## Parallel mapping using `map2()` | 2. Or with an anonymous function, conventional form:\n\n```{r}\n\nmap2_chr(nms, birth, function(x, y) paste(x, \"was born\", y)) %>% head()\n\n```\n\n## Parallel mapping using `map2()` | 3. Or with an anonymous function via formula:\n\n- Use `.x` and `.y` to refer to individual elements of the two primary inputs:\n\n```{r}\n\nmap2_chr(nms[16:18], birth[16:18], ~ paste(.x, \"was born\", .y))\n\n```\n\n## Parallel mapping using `pmap()`\n\nUse `pmap()` to map a function over two or more vectors or lists in parallel.\n\nUsage:\n\n- `pmap(.l, .f, ...)`\n\nor\n\n- `pmap(LIST_OF_INPUT_LISTS, FUNCTION_TO_APPLY, OPTIONAL_OTHER_STUFF)`\n\n## Parallel mapping using `pmap()`\n\nFunction creates sentence for each character stating name, number of aliases and allegiances:\n\n```{r}\n\ndf <- got_chars %>% {\n  tibble::tibble(\n    name = map_chr(., \"name\"),\n    aliases = map(., \"aliases\"),\n    allegiances = map(., \"allegiances\")\n  )\n}\n\nmy_fun <- function(name, aliases, allegiances) {\n  paste(name, \"has\", length(aliases), \"aliases and\", length(allegiances), \"allegiances\")\n}\n\ndf %>% \n  pmap_chr(my_fun) %>% \n  tail(n = 5)\n\n```\n\n## `walk()`\n\n- `walk()` calls `.f` exclusively for its side-effect (rather than its return value) and returns the original input\n    - typically do this because you want to render output to the screen or save files to disk\n        - important thing is the action, not the return value\n- `walk2()` and `pwalk()` are generally more useful\n    - all invisibly return the `.x`, the first argument.  This makes them suitable for use in the middle of pipelines.\n      \n```{r}\n\nplots <- mtcars %>% \n  split(.$cyl) %>% \n  map(~ggplot(., aes(mpg, wt)) + geom_point())\npaths <- paste0(names(plots), \".pdf\")\n\npwalk(list(paths, plots), ggsave, path = tempdir())\n\n```\n\n## `reduce()`\n\n- `reduce()` reduces a list to a single value by iteratively applying a binary function (i.e. function with two primary inputs)\n- `reduce()` combines from the left, `reduce_right()` combines from the right\n- useful in combination with joins, to bind a list of dataframes together by a common variable/key\n- Might have a list of dataframes, and you want to _reduce_ to a single data frame by joining the elements together:\n\n```{r}\n\ndfs <- list(\n  age = tibble(name = \"John\", age = 30),\n  sex = tibble(name = c(\"John\", \"Mary\"), sex = c(\"M\", \"F\")),\n  trt = tibble(name = \"Mary\", treatment = \"A\")\n)\n\ndfs %>% reduce(full_join, by = \"name\")\n\n```\n\n## `keep()`\n\n- similar to `filter()`, keeps an element using a predicate function (function that returns either a single `TRUE` or `FALSE`)\n\n```{r}\n\ngot_chars %>% \n  keep(\"alive\") %>% \n  map_df(extract, c(\"name\", \"culture\", \"gender\", \"alive\")) %>% \n  head(n = 5) %>% \n  kable()\n\n```\n\n## `discard()`\n\n- opposite of `keep()`, discards an element using a predicate function\n\n```{r}\n\ngot_chars %>% \n  discard(\"alive\") %>% \n  map_df(extract, c(\"name\", \"culture\", \"gender\", \"alive\")) %>% \n  head(n = 5) %>% \n  kable()\n\n```\n\n# `purrr` success story\n\n## Scenario\n\n- Reading in dozens of excel tables of different sizes and formats from different files to combine into one dataframe for Optimization Group.\n\n## Long, tedious non-`purrr` way to do this\n\n- I had over 1000 lines of code to do this at first with a different `read_excel()` call for each table \n- I had over 1000 lines of code to do this at first with a different `read_excel()` call for each table\n- :(\n- https://gitlab.com/methodsconsultants/optimization-group/marketing-impact/commit/c70aef043c4989b12b88fbf19f1fea6b9a9edd60\n\n## Quick, easy way to do this involving `purrr`\n\n- With Clayton's guidance, reduced to under 50 lines of code by creating a file with details about each specific table's sheet, index, cell range, and other information, writing a function to read all files in, and using a `pmap_df()` call.\n- :)\n- https://gitlab.com/methodsconsultants/optimization-group/marketing-impact/tree/co_data_prep/data_prep/CA\n\n",
    "created" : 1498829103898.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2697720118",
    "id" : "5A595A1B",
    "lastKnownWriteTime" : 1499286506,
    "last_content_update" : 1499286881516,
    "path" : "~/Documents/tutorials/purrr_tutorial/purrr_tutorial_slides.Rmd",
    "project_path" : "purrr_tutorial_slides.Rmd",
    "properties" : {
        "chunk_output_type" : "console",
        "last_setup_crc32" : "",
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}